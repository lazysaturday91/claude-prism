# claude-prism — 설계 문서

> 복잡한 문제를 구성요소로 분해하는 프리즘

---

## 1. 한 줄 요약

**AI가 삽질하기 전에, 먼저 이해하고 나눠서 풀게 만드는 도구.**

---

## 2. 문제 정의

### AI 코딩의 가장 큰 실패 모드

```
사용자: "auth 기능 만들어줘"

AI의 실제 행동:
  "auth? 알지." → 바로 코드 작성 → 30분 자율 실행 → 결과 확인
  → 사용자가 원한 것과 다름

왜?
  1. 안 물어봄 — "JWT? Session? OAuth?" 확인 없이 가정으로 진행
  2. 안 나눔 — 30분짜리 덩어리를 한번에 실행
  3. 안 멈춤 — 중간에 방향 확인 없이 끝까지 달림
```

### 근본 원인

| # | 원인 | 결과 |
|---|------|------|
| 1 | **이해 부족** — 정보를 수집하지 않고 가정으로 진행 | 결과물 왜곡 |
| 2 | **분해 부족** — 큰 덩어리를 한번에 실행 | 방향 이탈, 디버깅 지옥 |
| 3 | **확인 부족** — 중간 체크포인트 없이 달림 | 되돌리기 어려운 상태 |

### 핵심 인사이트

```
TDD를 안 지키는 것      → 짜증나지만 수습 가능
커밋 메시지 형식         → 사소함
AI가 엉뚱한 방향으로 달림 → 시간 + 토큰 + 결과물 전부 날림
```

**가장 비싼 실패는 "틀린 것을 열심히 만드는 것"이다.**

이해 + 분해가 이 실패를 방지한다. 이해하면 방향이 맞고, 분해하면 틀려도 빨리 잡힌다.

---

## 3. UDEC 프레임워크

prism의 핵심 방법론. 모든 규칙과 기능이 여기서 파생됨.

```
U — UNDERSTAND (이해)     "무엇을, 왜, 어떤 제약 하에?"
D — DECOMPOSE (분해)      "어떤 단위로, 어떤 순서로?"
E — EXECUTE (실행)        "한 단위씩, 검증하며"
C — CHECKPOINT (확인)     "맞는 방향인가? 조정 필요한가?"

U → D → E → C ──→ (OK) 다음 배치
                └→ (이상) U로 돌아감
```

---

## 4. UNDERSTAND — 이해 프로토콜

### 4-1. 정보 충분성 판별

```
사용자 요청 수신
    ↓
[충분] 구체적 파일, 함수, 증상이 명시됨
  → 바로 DECOMPOSE로
  예: "src/auth.ts의 validateToken에서 만료 체크 빠져있어"

[부분적] 방향은 있지만 세부사항 부족
  → 코드 탐색 후 1-2개 질문
  예: "로그인 기능 추가해줘"

[불충분] 추상적, 모호, 여러 해석 가능
  → 반드시 질문 먼저
  예: "성능 개선해줘", "리팩토링 해줘", "auth 만들어줘"
```

### 4-2. 질문 5규칙

**규칙 1: 한 번에 한 질문**
```
❌ "인증 방식은? DB는? 테스트 프레임워크는?"
✅ "인증 방식을 선택해주세요:
    (1) JWT — stateless, API 서버에 적합 (추천)
    (2) Session — 전통적, SSR에 적합"
```

**규칙 2: 객관식 우선 — 2-3개 선택지 + 추천 의견**
```
❌ "어떤 방식으로 할까요?"
✅ "(1) JWT (추천) (2) Session — 어떤 걸 선호하세요?"
```

**규칙 3: 질문에 근거 포함 — 코드를 먼저 탐색**
```
❌ "JWT 쓸까요?"
✅ "현재 Next.js API Routes 기반이라 JWT가 자연스럽습니다. JWT로 진행할까요?"
  → 프로젝트 구조를 먼저 파악한 뒤 맥락에 맞는 질문
```

**규칙 4: 최대 3라운드**
```
Round 1: 핵심 방향 (what) — "무엇을 만들 건가요?"
Round 2: 제약 조건 (how) — "기존 코드와 어떻게 통합?"
Round 3: 우선순위 (scope) — "MVP 범위는 어디까지?"

3라운드 이내에 충분하지 않으면:
  → 확보한 정보 기반 최소 범위 제안 → 승인 후 시작
```

**규칙 5: 탐색 먼저, 질문은 그 다음**
```
사용자: "auth 만들어줘"
    ↓
먼저: package.json, 기존 auth 파일, 프로젝트 구조 탐색
    ↓
그 다음: 탐색 결과 기반 질문
  "Next.js + Prisma 프로젝트이고 auth 코드가 없습니다.
   (1) NextAuth.js (추천) (2) 직접 구현 (JWT+bcrypt) (3) Supabase Auth"
```

### 4-3. 합의 확인

DECOMPOSE로 넘어가기 전 확인:

```
□ 목표가 한 문장으로 정리됨
□ 기술 스택/방식이 합의됨
□ 범위(MVP)가 명확함
□ 사용자가 "진행해"라고 확인함
```

---

## 5. DECOMPOSE — 분해 프로토콜

### 5-1. 좋은 분해의 5원칙

```
1. 단위 크기: 2-5분 (테스트/구현/검증 각각 별도 스텝)
2. 테스트 선행: 각 기능의 테스트가 구현보다 먼저
3. 독립 검증: 각 단위 끝에 "통과 기준"이 있음
4. 파일 명시: 생성/수정할 파일이 적혀 있음
5. 의존성 명시: 이전 단위에 의존하면 표기
```

### 5-2. 분해 품질 비교

```
❌ 나쁜 분해 (목차 수준):
1. 백엔드 구현
2. 프론트엔드 구현
3. 테스트 작성

❌ 나쁜 분해 (테스트 후행):
1. auth.ts 생성
2. login 함수 작성
3. token 생성
4. middleware 작성
5. 테스트 작성 ← 마지막

✅ 좋은 분해:
Batch 1: Login API
  1.1 테스트 작성 → tests/auth.test.ts
  1.2 구현 → src/auth/login.ts
  1.3 검증 → npm test → 통과 확인
  1.4 커밋 → "feat(auth): add login endpoint"
  --- checkpoint ---
Batch 2: JWT Token
  2.1 테스트 작성 → tests/auth.test.ts (추가)
  2.2 구현 → src/auth/token.ts
  2.3 검증 → npm test → 통과 확인
  2.4 커밋 → "feat(auth): add JWT token generation"
  --- checkpoint ---
```

### 5-3. 복잡도별 분해 수준

```
[단순] 1-2 파일, 명확한 지시
  → 분해 불필요. 바로 실행.
  예: "이 함수에서 null check 추가"

[보통] 3-5 파일, 한 기능
  → 2-3 배치로 분해
  예: "로그인 API 추가"

[복잡] 6+ 파일, 여러 기능
  → 5+ 배치, plan 파일 생성 필수
  예: "인증 시스템 전체 구현"

[복잡계] 범위 불명확, 여러 해석 가능
  → UNDERSTAND 필수 → 범위 축소 후 분해
  예: "성능 개선", "리팩토링"
```

### 5-4. 복잡계 문제의 분해 전략

```
"모든 것을 미리 계획하지 않는다.
 알 수 있는 만큼만 계획하고, 실행하며 배운다."

1단계: 탐색적 분해
  전체를 이해하려 하지 말고, "이해할 수 있는 부분"부터
  예: "성능 개선" → 먼저 프로파일링 → 병목 식별

2단계: 점진적 확장
  첫 배치 실행 후 얻은 정보로 다음 분해 조정
  예: 프로파일링 결과 → DB 쿼리가 병목 → DB 최적화 계획

3단계: 재평가 루프
  배치 완료마다 "전체 방향이 맞는가?" 재평가
  필요시 UNDERSTAND로 돌아감
```

### 5-5. Plan 파일 템플릿

```markdown
# Plan: [목표 한 줄]

## 합의 사항
- 방식: [기술 선택]
- 범위: [MVP 스코프]
- 제약: [기존 코드 호환 등]

## Batch 1: [소주제]
- [ ] 1.1 테스트: [무엇] → [파일]
- [ ] 1.2 구현: [무엇] → [파일]
- [ ] 1.3 검증: [명령어] → 통과 확인
- [ ] 1.4 커밋: "[메시지]"
--- checkpoint ---

## Batch 2: [소주제]
- [ ] 2.1 ...
```

저장 위치: `docs/plans/YYYY-MM-DD-<topic>.md`

---

## 6. EXECUTE — 실행 프로토콜

### 6-1. 배치 실행

```
배치 시작
    ↓
[테스트 작성] → 실행 → 실패 확인 (Red)
[구현] → 실행 → 테스트 통과 (Green)
[전체 검증] → npm test → 통과 확인
[커밋] → conventional commit
    ↓
CHECKPOINT
```

### 6-2. TDD Iron Law

```
1. 실패하는 테스트를 먼저 작성한다
2. 테스트를 통과하는 최소 코드를 작성한다
3. 테스트 없이 커밋하지 않는다
4. 검증 없이 완료를 선언하지 않는다
```

### 6-3. 체계적 디버깅

```
1단계: 근본 원인 조사
  에러 메시지 정독 → 재현 → 최근 변경 확인 → 데이터 흐름 추적

2단계: 패턴 분석
  작동하는 유사 코드 찾기 → 차이점 비교

3단계: 가설 검증
  단일 가설 → 최소 변경 → 한 번에 하나만 테스트

4단계: 구현
  실패 테스트 작성 → 단일 수정 → 검증

⚠️ 3회 수정 실패 시: STOP.
  "접근 방식에 문제가 있을 수 있습니다. 확인 후 진행할까요?"
```

### 6-4. 자기 교정 메커니즘

```
[같은 파일 3회+ 편집]
  → "삽질 가능성. 근본 원인부터 파악합니다."

[계획에 없는 파일 수정]
  → "계획에 없는 파일입니다. 스코프 변경이 필요한가요?"

[3회 연속 테스트 실패]
  → "접근 방식에 문제가 있을 수 있습니다."
  → UNDERSTAND로 돌아감

[새 패키지 설치 필요]
  → "새 의존성: [패키지명]. 설치할까요?"

[5턴 연속 자율 실행]
  → "5턴째 자율 실행 중. 현재 상태 보고 후 계속합니다."
```

---

## 7. CHECKPOINT — 확인 프로토콜

### 7-1. 배치 체크포인트

```
매 배치(3-4 태스크) 완료 후:

"Batch 1 완료.
 ✅ login API 구현, 테스트 3개 통과
 다음: Batch 2 — JWT 토큰 생성
 계속 진행할까요?"

사용자 응답:
  "ㅇㅇ"          → Batch 2 시작
  "방향 바꾸자"    → UNDERSTAND로
  "여기까지만"     → 종료
```

### 7-2. /checkpoint 커맨드

사용자가 언제든 진행 상태 확인 가능:

```
/checkpoint 실행 시:

📊 Progress: auth 기능 구현
━━━━━━━━━━━━━━━━━━━━━━━

✅ Batch 1: Login API (완료)
   - login.ts, login.test.ts
   - 테스트 3개 통과
   - 커밋: feat(auth): add login

🔄 Batch 2: JWT Token (진행 중)
   - [x] 2.1 테스트 작성
   - [ ] 2.2 구현
   - [ ] 2.3 검증

⏳ Batch 3: Middleware (대기)

계속 진행할까요?
```

---

## 8. 합리화 방어

AI가 규칙을 어기려 할 때 스스로 자각하게 하는 체크리스트:

| 변명 | 현실 |
|------|------|
| "너무 단순해서 분해 불필요" | 3파일 이상이면 무조건 분해 |
| "사용자가 바쁠 테니 안 물어봐야지" | 모호하면 반드시 질문. 추측 금지 |
| "질문이 너무 많으면 짜증낼 거야" | 최대 3라운드, 객관식, 근거 포함 |
| "계획은 세웠으니 끝까지 따르자" | 배치마다 재평가. 고정 계획은 없음 |
| "테스트 나중에 몰아서 하자" | 각 단위에 테스트가 먼저 |
| "커밋은 다 끝나고 한번에" | 배치마다 커밋 |
| "이번만 건너뛰자" | 예외는 없다 |
| "사용자가 진행하라고 했으니까" | 한번 승인 ≠ 무한 위임 |

---

## 9. 완료 선언 규칙

검증 없이 아래 표현 사용 금지:
```
❌ "~할 것입니다", "~일 겁니다", "아마", "~인 것 같습니다"
```

완료 선언 전 반드시:
```
1. IDENTIFY — 무엇이 완료를 증명하는가?
2. RUN — 해당 테스트/빌드 실행
3. READ — 출력 직접 확인
4. CLAIM — 증거 기반으로만 완료 선언
```

---

## 10. 제품 구성

### 10-1. 설치되는 것

```
npx claude-prism init
    ↓
1. CLAUDE.md 규칙 주입
   ├── UDEC 프레임워크
   ├── 정보 충분성 판별 프로토콜
   ├── 질문 5규칙
   ├── 분해 5원칙 + 복잡도별 수준
   ├── 배치 실행 프로토콜
   ├── 자기 교정 메커니즘
   ├── TDD Iron Law
   ├── 체계적 디버깅
   ├── 합리화 방어
   └── 완료 선언 규칙

2. 슬래시 커맨드 2개
   ├── /prism — UDEC 전체 실행 (이해 → 분해 → 실행 → 확인)
   └── /checkpoint — 진행 상태 확인 + 방향 확인

3. Hook 2개 (선택)
   ├── commit-guard — 테스트 없이 커밋 차단 (exit 2)
   └── debug-loop — 동일 파일 5회 편집 차단 (exit 2)
```

### 10-2. 설치 결과 디렉토리

```
.claude/
├── commands/
│   ├── prism.md            # /prism 커맨드
│   └── checkpoint.md       # /checkpoint 커맨드
├── hooks/                  # (선택 설치)
│   ├── commit-guard.mjs
│   └── debug-loop.mjs
└── settings.json           # hook 설정 (선택)

CLAUDE.md                   # 규칙 주입 (<!-- PRISM:START --> ... <!-- PRISM:END -->)
```

### 10-3. /prism 커맨드 동작

```
사용자: /prism auth 기능 구현

Claude가 따르는 흐름:

[UNDERSTAND]
1. 코드 탐색 — package.json, 기존 구조 파악
2. 정보 충분성 판별
3. 부족하면 질문 (객관식, 최대 3라운드)
4. 합의 확인

[DECOMPOSE]
5. 복잡도 판별
6. 배치 단위 분해
7. docs/plans/YYYY-MM-DD-auth.md 저장
8. "이 계획으로 진행할까요?"

[EXECUTE]
9. Batch 1 실행 (테스트→구현→검증→커밋)

[CHECKPOINT]
10. "Batch 1 완료. 다음은 Batch 2. 계속할까요?"
11. 사용자 확인 후 반복
```

### 10-4. CLI 명령어

```bash
npx claude-prism init [--lang=en|ko|zh|ja]   # 설치
npx claude-prism check                        # 설치 검증
npx claude-prism update                       # 업데이트
npx claude-prism uninstall                    # 제거
```

---

## 11. 기술 사양

### 11-1. 기본 원칙

```
- Zero dependencies (순수 Node.js)
- Node.js >= 18
- ES Module
- Claude Code hooks API 활용
```

### 11-2. 소스 구조

```
claude-prism/
├── bin/
│   └── cli.mjs                # CLI 진입점
├── lib/
│   ├── config.mjs             # .prism.json 설정 로더
│   ├── state.mjs              # 세션 상태 관리
│   └── utils.mjs              # 유틸리티
├── hooks/
│   ├── commit-guard.mjs       # 테스트 없이 커밋 차단
│   └── debug-loop.mjs         # 반복 편집 차단
├── templates/
│   ├── rules.en.md            # English CLAUDE.md 규칙
│   ├── rules.ko.md            # Korean
│   ├── rules.zh.md            # Chinese
│   ├── rules.ja.md            # Japanese
│   ├── commands/
│   │   ├── prism.md           # /prism 커맨드
│   │   └── checkpoint.md      # /checkpoint 커맨드
│   └── settings.json          # hook 설정 템플릿
├── tests/
│   ├── hooks.test.mjs         # hook 단위 테스트
│   └── cli.test.mjs           # CLI 테스트
├── package.json
├── README.md
└── README.ko.md
```

### 11-3. 설정 파일

```json
// .prism.json
{
  "language": "ko",
  "hooks": {
    "commit-guard": { "enabled": true, "maxTestAge": 300 },
    "debug-loop": { "enabled": true, "warnAt": 3, "blockAt": 5 }
  }
}
```

---

## 12. 구현 순서

### Phase 1: 코어 (이것만으로 동작)
```
1. package.json + 디렉토리 구조
2. CLAUDE.md 규칙 템플릿 (ko, en)
3. /prism 슬래시 커맨드
4. /checkpoint 슬래시 커맨드
5. CLI: prism init (규칙 주입 + 커맨드 설치)
6. CLI: prism check (설치 검증)
7. 테스트
```

### Phase 2: 강제 (선택)
```
8. commit-guard hook
9. debug-loop hook
10. CLI: init에 hook 선택 옵션 추가
11. hook 테스트
```

### Phase 3: 편의
```
12. prism update
13. prism uninstall
14. zh, ja 템플릿
15. README 작성
```

---

## 13. 설계 원칙

```
1. 방법론이 본체, 도구는 설치 도우미
   → 가치는 CLAUDE.md 규칙과 /prism 커맨드에 있음. npm 패키지는 이걸 쉽게 넣어주는 것뿐.

2. Less is more
   → 2개 커맨드, 2개 hook. 이상.

3. 노이즈 = 신뢰 파괴
   → hook이 말하면 진짜 중요한 거. false positive 없어야 함.

4. 분해가 모든 것의 기반
   → TDD, 디버깅, 방향 정렬 전부 "분해를 잘 했는가"에서 시작.

5. 이해 없는 실행 금지
   → 모호하면 멈추고 물어본다. 추측하지 않는다.
```
