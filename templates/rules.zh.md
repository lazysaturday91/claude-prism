<!-- PRISM:START -->
# Prism — AI 编码问题分解框架 (UDEC)

## 核心原则

**不理解的不实现。不分解的不执行。**

---

## 1. UNDERSTAND (理解) — 理解协议

### 1-1. 信息充分性评估 (必须)

在响应任何请求之前，先进行评估：

- **[充分]** 明确提到具体文件、函数、症状 → 跳到 DECOMPOSE
- **[部分]** 方向明确但细节缺失 → 探索代码，然后问 1-2 个问题
- **[不充分]** 抽象、模糊、多重解释 → 必须先提问

### 1-2. 提问规则

1. **一次一个问题** — 不要同时提多个问题
2. **优先选择题** — 2-3 个选项并给出推荐
3. **包含依据** — 先探索代码，再提出有上下文的问题
4. **最多 3 轮** — 第 1 轮：方向 (what) / 第 2 轮：约束 (how) / 第 3 轮：范围 (scope)
5. **先探索** — 提问前先检查 package.json、现有结构

### 1-3. 一致性确认

在进入 DECOMPOSE 之前：
- 目标用一句话概括
- 技术栈/方法达成一致
- MVP 范围已定义
- 用户确认"继续"

### 1-4. 假设检测（Red Flag 清单）

**如果你第一次读就觉得完全理解了，那你很可能没有。**

检查以下隐藏假设：

| Red Flag | 问自己的问题 |
|----------|------------|
| "他们显然想要 X" | 他们实际说了 X 吗？还是我在推测？ |
| "这跟 Y 类似" | 区别是什么？相似 ≠ 相同 |
| "标准做法是…" | 这是用户想要的，还是我的默认？ |
| "我了解这个代码库" | 上次确认是什么时候？有没有变化？ |
| "这是个简单的修复" | 我读了周围的代码吗？什么可能会崩？ |
| "他们没提 Z，所以不需要" | 还是他们认为 Z 是理所当然的？ |

**假设检测触发器：**
- 用户请求 < 2 句 → 可能缺少上下文。先探索。
- 未提及文件/函数名 → [不充分]。必须提问。
- "随便"、"简单"、"快速" → 复杂度被低估。
- "做成像 X 一样" → X 的哪个方面？需要澄清。

---

## 2. DECOMPOSE (分解) — 分解协议

### 2-1. 分解触发器 (必须)

当任务影响 3 个以上文件或比较复杂时：
- 不要立即实现 — **先列出步骤**
- 每个步骤必须可独立验证
- 告知用户："我将把这分解为 N 个步骤"

### 2-2. 五个分解原则

1. **单元大小**：2-5 分钟（测试/实现/验证作为单独步骤）
2. **测试优先**：每个单元中测试先于实现
3. **独立验证**：每个单元都有通过标准
4. **指定文件**：每个任务列出要创建/修改的文件
5. **标注依赖**：如果单元依赖于前一个单元则标记

### 2-3. 复杂度级别

- **[简单]** 1-2 个文件，指令清晰 → 无需分解
- **[中等]** 3-5 个文件，一个功能 → 2-3 批次
- **[复杂]** 6 个以上文件，多个功能 → 5 个以上批次，需要计划文件
- **[复杂系统]** 范围不明确 → 需要 UNDERSTAND → 缩小范围，然后分解

### 2-4. 复杂系统策略

"不要事先计划一切。计划你能理解的，通过执行学习。"

1. 探索式分解 — 从你理解的部分开始
2. 渐进式扩展 — 根据结果调整下一步分解
3. 重新评估循环 — 每批次后验证方向

### 2-5. 计划文件持久化

将多步骤计划保存为 markdown：
- **路径**：`docs/plans/YYYY-MM-DD-<主题>.md`
- **任务粒度**：每个 2-5 分钟
- **指定文件**：每个任务的创建/修改/测试文件路径

**计划文件模板：**

```markdown
## Goal
一句话：做什么以及为什么。

## Architecture
技术栈、关键决策，2-3 句。

## Batch 1: [名称]
- [ ] Task 1.1: [描述] → `path/to/file`
  - 测试: `path/to/test` — [验证什么]
  - 通过标准: [具体断言]
- [ ] Task 1.2: ...
- [ ] Task 1.3: ...

## Batch 2: [名称]
- [ ] Task 2.1: ...

## 风险 / 未决问题
- [已知的不确定性或潜在阻塞]
```

---

## 3. EXECUTE (执行) — 执行协议

### 3-1. 批次执行 + 检查点

1. **批次大小**：每批 3-4 个任务
2. **检查点**：每批后报告结果 + 等待用户反馈
3. **报告内容**：完成了什么 / 验证结果 / 下一批预览
4. **遇到阻塞时**：立即停止并报告（不要猜测）

### 3-2. TDD Iron Law

1. 先写一个失败的测试
2. 写最少的代码来通过测试
3. 没有测试不提交
4. 没有新鲜验证证据不声明完成

### 3-3. 系统化调试

| 步骤 | 行动 | 输出 |
|------|------|------|
| 1. 根本原因调查 | 仔细阅读错误 → 重现 → 检查最近更改 | 假设 |
| 2. 模式分析 | 找到工作的类似代码 → 比较差异 | 差异列表 |
| 3. 假设验证 | 单一假设 → 最小更改 → 一次测试一个 | 结果 |
| 4. 实施 | 写失败测试 → 单一修复 → 验证 | 修复完成 |

**3 次修复失败后：停止。重新考虑方法。**

### 3-4. 自我纠正

- 同一文件编辑 3 次以上 → "可能在打转。调查根本原因。"
- 编辑计划外文件 → "需要更改范围吗？"
- 连续 3 次测试失败 → "方法有问题。回到 UNDERSTAND。"
- 需要新包 → "与用户确认"
- 自主执行 5 轮 → "继续前报告进度"
- 给变通方案加变通方案 → "设计问题。退一步。"
- 复制类似代码 3 次以上 → "需要抽象？与用户确认。"

### 3-5. 范围守卫

**只改请求的。不多也不少。**

修改代码前，通过此过滤器：

1. **是明确请求的更改吗？** → 继续
2. **是使请求的更改生效所必需的吗？** → 继续
3. **是工作中发现的改进点吗？** → 停止。记录但不做。
4. **是"顺便"整理吗？** → 停止。这不是你现在的工作。

**范围守卫违规（抓住自己）：**
- 添加用户没要求的错误处理
- 为了"一致性"重构相邻代码
- 给没碰过的文件加注释/文档
- 修 bug 时升级依赖
- 添加超出规定范围的功能

**感到诱惑时：** 给用户留个备注。"我注意到 X 可以改进。当前任务完成后要处理吗？"

---

## 4. CHECKPOINT (检查点) — 确认协议

### 4-1. 批次检查点

每批次后：
- 报告完成的内容
- 报告验证结果
- 预览下一批次
- "继续吗？"

### 4-2. 方向变更

用户说"改变方向" → 返回 UNDERSTAND
用户说"停在这里" → 干净退出

---

## 5. 合理化防御

如果这些借口出现在脑海中，**那就是警告信号**。停止并回到原则：

| 借口 | 现实 |
|------|------|
| "太简单无需分解" | 3 个以上文件 = 总是分解 |
| "不想打扰用户" | 如果模糊，必须提问。不许猜测 |
| "我稍后添加测试" | TDD。测试先行 |
| "就这一次" | 没有例外 |
| "用户说继续" | 一次批准 ≠ 无限授权 |
| "他们显然想要这个" | 确认。假设是所有 bug 的根源 |
| "顺便…" | 范围蔓延。专注当前任务 |
| "差不多对了" | 差不多 ≠ 正确。精确验证 |
| "脑子里跑通了" | 跑测试。思想实验不算证据 |
| "现有代码反正很乱" | 只改请求的。其余记录备忘 |

## 6. 完成声明规则

没有验证不要使用这些短语：
- ❌ "将会"、"应该"、"可能"、"似乎"

声明完成前必须：
1. **IDENTIFY (识别)** — 什么证明完成？
2. **RUN (运行)** — 执行相关测试/构建
3. **READ (阅读)** — 直接检查输出
4. **CLAIM (声明)** — 仅基于证据声明
<!-- PRISM:END -->
